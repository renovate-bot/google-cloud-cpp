// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the Codegen C++ plugin.
// If you make any local changes, they will be lost.
// source: google/cloud/visionai/v1/warehouse.proto

#include "google/cloud/visionai/v1/internal/warehouse_connection_impl.h"
#include "google/cloud/visionai/v1/internal/warehouse_option_defaults.h"
#include "google/cloud/background_threads.h"
#include "google/cloud/common_options.h"
#include "google/cloud/grpc_options.h"
#include "google/cloud/internal/async_long_running_operation.h"
#include "google/cloud/internal/pagination_range.h"
#include "google/cloud/internal/retry_loop.h"
#include <memory>
#include <utility>

namespace google {
namespace cloud {
namespace visionai_v1_internal {
GOOGLE_CLOUD_CPP_INLINE_NAMESPACE_BEGIN
namespace {

std::unique_ptr<visionai_v1::WarehouseRetryPolicy> retry_policy(
    Options const& options) {
  return options.get<visionai_v1::WarehouseRetryPolicyOption>()->clone();
}

std::unique_ptr<BackoffPolicy> backoff_policy(Options const& options) {
  return options.get<visionai_v1::WarehouseBackoffPolicyOption>()->clone();
}

std::unique_ptr<visionai_v1::WarehouseConnectionIdempotencyPolicy>
idempotency_policy(Options const& options) {
  return options.get<visionai_v1::WarehouseConnectionIdempotencyPolicyOption>()
      ->clone();
}

std::unique_ptr<PollingPolicy> polling_policy(Options const& options) {
  return options.get<visionai_v1::WarehousePollingPolicyOption>()->clone();
}

}  // namespace

WarehouseConnectionImpl::WarehouseConnectionImpl(
    std::unique_ptr<google::cloud::BackgroundThreads> background,
    std::shared_ptr<visionai_v1_internal::WarehouseStub> stub, Options options)
    : background_(std::move(background)),
      stub_(std::move(stub)),
      options_(internal::MergeOptions(std::move(options),
                                      WarehouseConnection::options())) {}

StatusOr<google::cloud::visionai::v1::Asset>
WarehouseConnectionImpl::CreateAsset(
    google::cloud::visionai::v1::CreateAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::CreateAssetRequest const& request) {
        return stub_->CreateAsset(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::Asset>
WarehouseConnectionImpl::UpdateAsset(
    google::cloud::visionai::v1::UpdateAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UpdateAssetRequest const& request) {
        return stub_->UpdateAsset(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::Asset> WarehouseConnectionImpl::GetAsset(
    google::cloud::visionai::v1::GetAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GetAssetRequest const& request) {
        return stub_->GetAsset(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::Asset>
WarehouseConnectionImpl::ListAssets(
    google::cloud::visionai::v1::ListAssetsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListAssets(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::Asset>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListAssetsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](
                grpc::ClientContext& context, Options const& options,
                google::cloud::visionai::v1::ListAssetsRequest const& request) {
              return stub->ListAssets(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListAssetsResponse r) {
        std::vector<google::cloud::visionai::v1::Asset> result(
            r.assets().size());
        auto& messages = *r.mutable_assets();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

future<StatusOr<google::cloud::visionai::v1::DeleteAssetMetadata>>
WarehouseConnectionImpl::DeleteAsset(
    google::cloud::visionai::v1::DeleteAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->DeleteAsset(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::DeleteAssetMetadata>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::DeleteAssetRequest const& request) {
        return stub->AsyncDeleteAsset(cq, std::move(context),
                                      std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteAssetMetadata>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::DeleteAsset(
    NoAwaitTag,
    google::cloud::visionai::v1::DeleteAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::DeleteAssetRequest const& request) {
        return stub_->DeleteAsset(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeleteAssetMetadata>>
WarehouseConnectionImpl::DeleteAsset(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::DeleteAssetMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::DeleteAssetMetadata>>(
        internal::InvalidArgumentError(
            "operation does not correspond to DeleteAsset",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::DeleteAssetMetadata>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteAssetMetadata>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::UploadAssetResponse>>
WarehouseConnectionImpl::UploadAsset(
    google::cloud::visionai::v1::UploadAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->UploadAsset(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::UploadAssetResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::UploadAssetRequest const& request) {
        return stub->AsyncUploadAsset(cq, std::move(context),
                                      std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::UploadAssetResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::UploadAsset(
    NoAwaitTag,
    google::cloud::visionai::v1::UploadAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UploadAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UploadAssetRequest const& request) {
        return stub_->UploadAsset(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::UploadAssetResponse>>
WarehouseConnectionImpl::UploadAsset(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::UploadAssetMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::UploadAssetResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to UploadAsset",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::UploadAssetResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::UploadAssetResponse>,
      polling_policy(*current), __func__);
}

StatusOr<google::cloud::visionai::v1::GenerateRetrievalUrlResponse>
WarehouseConnectionImpl::GenerateRetrievalUrl(
    google::cloud::visionai::v1::GenerateRetrievalUrlRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GenerateRetrievalUrl(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GenerateRetrievalUrlRequest const&
                 request) {
        return stub_->GenerateRetrievalUrl(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeAssetResponse>>
WarehouseConnectionImpl::AnalyzeAsset(
    google::cloud::visionai::v1::AnalyzeAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->AnalyzeAsset(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::AnalyzeAssetResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::AnalyzeAssetRequest const& request) {
        return stub->AsyncAnalyzeAsset(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::AnalyzeAssetResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::AnalyzeAsset(
    NoAwaitTag,
    google::cloud::visionai::v1::AnalyzeAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->AnalyzeAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::AnalyzeAssetRequest const& request) {
        return stub_->AnalyzeAsset(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeAssetResponse>>
WarehouseConnectionImpl::AnalyzeAsset(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::AnalyzeAssetMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::AnalyzeAssetResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to AnalyzeAsset",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::AnalyzeAssetResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::AnalyzeAssetResponse>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::IndexAssetResponse>>
WarehouseConnectionImpl::IndexAsset(
    google::cloud::visionai::v1::IndexAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->IndexAsset(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::IndexAssetResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::IndexAssetRequest const& request) {
        return stub->AsyncIndexAsset(cq, std::move(context), std::move(options),
                                     request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::IndexAssetResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::IndexAsset(
    NoAwaitTag, google::cloud::visionai::v1::IndexAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->IndexAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::IndexAssetRequest const& request) {
        return stub_->IndexAsset(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::IndexAssetResponse>>
WarehouseConnectionImpl::IndexAsset(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::IndexAssetMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::IndexAssetResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to IndexAsset",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::IndexAssetResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::IndexAssetResponse>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::RemoveIndexAssetResponse>>
WarehouseConnectionImpl::RemoveIndexAsset(
    google::cloud::visionai::v1::RemoveIndexAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->RemoveIndexAsset(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::RemoveIndexAssetResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::RemoveIndexAssetRequest const& request) {
        return stub->AsyncRemoveIndexAsset(cq, std::move(context),
                                           std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::RemoveIndexAssetResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation>
WarehouseConnectionImpl::RemoveIndexAsset(
    NoAwaitTag,
    google::cloud::visionai::v1::RemoveIndexAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->RemoveIndexAsset(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::RemoveIndexAssetRequest const& request) {
        return stub_->RemoveIndexAsset(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::RemoveIndexAssetResponse>>
WarehouseConnectionImpl::RemoveIndexAsset(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::
                   RemoveIndexAssetMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::RemoveIndexAssetResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to RemoveIndexAsset",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::RemoveIndexAssetResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::RemoveIndexAssetResponse>,
      polling_policy(*current), __func__);
}

StreamRange<google::cloud::visionai::v1::IndexedAsset>
WarehouseConnectionImpl::ViewIndexedAssets(
    google::cloud::visionai::v1::ViewIndexedAssetsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ViewIndexedAssets(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::IndexedAsset>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ViewIndexedAssetsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ViewIndexedAssetsRequest const&
                       request) {
              return stub->ViewIndexedAssets(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ViewIndexedAssetsResponse r) {
        std::vector<google::cloud::visionai::v1::IndexedAsset> result(
            r.indexed_assets().size());
        auto& messages = *r.mutable_indexed_assets();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseConnectionImpl::CreateIndex(
    google::cloud::visionai::v1::CreateIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->CreateIndex(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::Index>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::CreateIndexRequest const& request) {
        return stub->AsyncCreateIndex(cq, std::move(context),
                                      std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Index>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::CreateIndex(
    NoAwaitTag,
    google::cloud::visionai::v1::CreateIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateIndex(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::CreateIndexRequest const& request) {
        return stub_->CreateIndex(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseConnectionImpl::CreateIndex(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::CreateIndexMetadata>()) {
    return make_ready_future<StatusOr<google::cloud::visionai::v1::Index>>(
        internal::InvalidArgumentError(
            "operation does not correspond to CreateIndex",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::Index>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Index>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseConnectionImpl::UpdateIndex(
    google::cloud::visionai::v1::UpdateIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->UpdateIndex(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::Index>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::UpdateIndexRequest const& request) {
        return stub->AsyncUpdateIndex(cq, std::move(context),
                                      std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Index>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::UpdateIndex(
    NoAwaitTag,
    google::cloud::visionai::v1::UpdateIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateIndex(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UpdateIndexRequest const& request) {
        return stub_->UpdateIndex(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseConnectionImpl::UpdateIndex(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::UpdateIndexMetadata>()) {
    return make_ready_future<StatusOr<google::cloud::visionai::v1::Index>>(
        internal::InvalidArgumentError(
            "operation does not correspond to UpdateIndex",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::Index>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Index>,
      polling_policy(*current), __func__);
}

StatusOr<google::cloud::visionai::v1::Index> WarehouseConnectionImpl::GetIndex(
    google::cloud::visionai::v1::GetIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetIndex(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GetIndexRequest const& request) {
        return stub_->GetIndex(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::Index>
WarehouseConnectionImpl::ListIndexes(
    google::cloud::visionai::v1::ListIndexesRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListIndexes(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::Index>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListIndexesRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ListIndexesRequest const&
                       request) {
              return stub->ListIndexes(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListIndexesResponse r) {
        std::vector<google::cloud::visionai::v1::Index> result(
            r.indexes().size());
        auto& messages = *r.mutable_indexes();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexMetadata>>
WarehouseConnectionImpl::DeleteIndex(
    google::cloud::visionai::v1::DeleteIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->DeleteIndex(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::DeleteIndexMetadata>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::DeleteIndexRequest const& request) {
        return stub->AsyncDeleteIndex(cq, std::move(context),
                                      std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteIndexMetadata>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::DeleteIndex(
    NoAwaitTag,
    google::cloud::visionai::v1::DeleteIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteIndex(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::DeleteIndexRequest const& request) {
        return stub_->DeleteIndex(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexMetadata>>
WarehouseConnectionImpl::DeleteIndex(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::DeleteIndexMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::DeleteIndexMetadata>>(
        internal::InvalidArgumentError(
            "operation does not correspond to DeleteIndex",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::DeleteIndexMetadata>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteIndexMetadata>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::Corpus>>
WarehouseConnectionImpl::CreateCorpus(
    google::cloud::visionai::v1::CreateCorpusRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->CreateCorpus(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::Corpus>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::CreateCorpusRequest const& request) {
        return stub->AsyncCreateCorpus(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Corpus>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::CreateCorpus(
    NoAwaitTag,
    google::cloud::visionai::v1::CreateCorpusRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateCorpus(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::CreateCorpusRequest const& request) {
        return stub_->CreateCorpus(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::Corpus>>
WarehouseConnectionImpl::CreateCorpus(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::CreateCorpusMetadata>()) {
    return make_ready_future<StatusOr<google::cloud::visionai::v1::Corpus>>(
        internal::InvalidArgumentError(
            "operation does not correspond to CreateCorpus",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::Corpus>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Corpus>,
      polling_policy(*current), __func__);
}

StatusOr<google::cloud::visionai::v1::Corpus>
WarehouseConnectionImpl::GetCorpus(
    google::cloud::visionai::v1::GetCorpusRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetCorpus(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GetCorpusRequest const& request) {
        return stub_->GetCorpus(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::Corpus>
WarehouseConnectionImpl::UpdateCorpus(
    google::cloud::visionai::v1::UpdateCorpusRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateCorpus(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UpdateCorpusRequest const& request) {
        return stub_->UpdateCorpus(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::Corpus>
WarehouseConnectionImpl::ListCorpora(
    google::cloud::visionai::v1::ListCorporaRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListCorpora(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::Corpus>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListCorporaRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ListCorporaRequest const&
                       request) {
              return stub->ListCorpora(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListCorporaResponse r) {
        std::vector<google::cloud::visionai::v1::Corpus> result(
            r.corpora().size());
        auto& messages = *r.mutable_corpora();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

Status WarehouseConnectionImpl::DeleteCorpus(
    google::cloud::visionai::v1::DeleteCorpusRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteCorpus(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::DeleteCorpusRequest const& request) {
        return stub_->DeleteCorpus(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeCorpusResponse>>
WarehouseConnectionImpl::AnalyzeCorpus(
    google::cloud::visionai::v1::AnalyzeCorpusRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->AnalyzeCorpus(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::AnalyzeCorpusResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::AnalyzeCorpusRequest const& request) {
        return stub->AsyncAnalyzeCorpus(cq, std::move(context),
                                        std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::AnalyzeCorpusResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::AnalyzeCorpus(
    NoAwaitTag,
    google::cloud::visionai::v1::AnalyzeCorpusRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->AnalyzeCorpus(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::AnalyzeCorpusRequest const& request) {
        return stub_->AnalyzeCorpus(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeCorpusResponse>>
WarehouseConnectionImpl::AnalyzeCorpus(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::AnalyzeCorpusMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::AnalyzeCorpusResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to AnalyzeCorpus",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::AnalyzeCorpusResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::AnalyzeCorpusResponse>,
      polling_policy(*current), __func__);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseConnectionImpl::CreateDataSchema(
    google::cloud::visionai::v1::CreateDataSchemaRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateDataSchema(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::CreateDataSchemaRequest const& request) {
        return stub_->CreateDataSchema(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseConnectionImpl::UpdateDataSchema(
    google::cloud::visionai::v1::UpdateDataSchemaRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateDataSchema(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::UpdateDataSchemaRequest const& request) {
        return stub_->UpdateDataSchema(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseConnectionImpl::GetDataSchema(
    google::cloud::visionai::v1::GetDataSchemaRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetDataSchema(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GetDataSchemaRequest const& request) {
        return stub_->GetDataSchema(context, options, request);
      },
      *current, request, __func__);
}

Status WarehouseConnectionImpl::DeleteDataSchema(
    google::cloud::visionai::v1::DeleteDataSchemaRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteDataSchema(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::DeleteDataSchemaRequest const& request) {
        return stub_->DeleteDataSchema(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::DataSchema>
WarehouseConnectionImpl::ListDataSchemas(
    google::cloud::visionai::v1::ListDataSchemasRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListDataSchemas(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::DataSchema>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListDataSchemasRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ListDataSchemasRequest const&
                       request) {
              return stub->ListDataSchemas(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListDataSchemasResponse r) {
        std::vector<google::cloud::visionai::v1::DataSchema> result(
            r.data_schemas().size());
        auto& messages = *r.mutable_data_schemas();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseConnectionImpl::CreateAnnotation(
    google::cloud::visionai::v1::CreateAnnotationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateAnnotation(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::CreateAnnotationRequest const& request) {
        return stub_->CreateAnnotation(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseConnectionImpl::GetAnnotation(
    google::cloud::visionai::v1::GetAnnotationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetAnnotation(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GetAnnotationRequest const& request) {
        return stub_->GetAnnotation(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::Annotation>
WarehouseConnectionImpl::ListAnnotations(
    google::cloud::visionai::v1::ListAnnotationsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListAnnotations(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::Annotation>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListAnnotationsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ListAnnotationsRequest const&
                       request) {
              return stub->ListAnnotations(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListAnnotationsResponse r) {
        std::vector<google::cloud::visionai::v1::Annotation> result(
            r.annotations().size());
        auto& messages = *r.mutable_annotations();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseConnectionImpl::UpdateAnnotation(
    google::cloud::visionai::v1::UpdateAnnotationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateAnnotation(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::UpdateAnnotationRequest const& request) {
        return stub_->UpdateAnnotation(context, options, request);
      },
      *current, request, __func__);
}

Status WarehouseConnectionImpl::DeleteAnnotation(
    google::cloud::visionai::v1::DeleteAnnotationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteAnnotation(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::DeleteAnnotationRequest const& request) {
        return stub_->DeleteAnnotation(context, options, request);
      },
      *current, request, __func__);
}

std::unique_ptr<::google::cloud::AsyncStreamingReadWriteRpc<
    google::cloud::visionai::v1::IngestAssetRequest,
    google::cloud::visionai::v1::IngestAssetResponse>>
WarehouseConnectionImpl::AsyncIngestAsset() {
  return stub_->AsyncIngestAsset(background_->cq(),
                                 std::make_shared<grpc::ClientContext>(),
                                 internal::SaveCurrentOptions());
}

StatusOr<google::cloud::visionai::v1::ClipAssetResponse>
WarehouseConnectionImpl::ClipAsset(
    google::cloud::visionai::v1::ClipAssetRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->ClipAsset(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::ClipAssetRequest const& request) {
        return stub_->ClipAsset(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::GenerateHlsUriResponse>
WarehouseConnectionImpl::GenerateHlsUri(
    google::cloud::visionai::v1::GenerateHlsUriRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GenerateHlsUri(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::GenerateHlsUriRequest const& request) {
        return stub_->GenerateHlsUri(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::ImportAssetsResponse>>
WarehouseConnectionImpl::ImportAssets(
    google::cloud::visionai::v1::ImportAssetsRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->ImportAssets(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::ImportAssetsResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::ImportAssetsRequest const& request) {
        return stub->AsyncImportAssets(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::ImportAssetsResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::ImportAssets(
    NoAwaitTag,
    google::cloud::visionai::v1::ImportAssetsRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->ImportAssets(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::ImportAssetsRequest const& request) {
        return stub_->ImportAssets(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::ImportAssetsResponse>>
WarehouseConnectionImpl::ImportAssets(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::ImportAssetsMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::ImportAssetsResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to ImportAssets",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::ImportAssetsResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::ImportAssetsResponse>,
      polling_policy(*current), __func__);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseConnectionImpl::CreateSearchConfig(
    google::cloud::visionai::v1::CreateSearchConfigRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateSearchConfig(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::CreateSearchConfigRequest const&
                 request) {
        return stub_->CreateSearchConfig(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseConnectionImpl::UpdateSearchConfig(
    google::cloud::visionai::v1::UpdateSearchConfigRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateSearchConfig(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UpdateSearchConfigRequest const&
                 request) {
        return stub_->UpdateSearchConfig(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseConnectionImpl::GetSearchConfig(
    google::cloud::visionai::v1::GetSearchConfigRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetSearchConfig(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::GetSearchConfigRequest const& request) {
        return stub_->GetSearchConfig(context, options, request);
      },
      *current, request, __func__);
}

Status WarehouseConnectionImpl::DeleteSearchConfig(
    google::cloud::visionai::v1::DeleteSearchConfigRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteSearchConfig(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::DeleteSearchConfigRequest const&
                 request) {
        return stub_->DeleteSearchConfig(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::SearchConfig>
WarehouseConnectionImpl::ListSearchConfigs(
    google::cloud::visionai::v1::ListSearchConfigsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListSearchConfigs(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::SearchConfig>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListSearchConfigsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ListSearchConfigsRequest const&
                       request) {
              return stub->ListSearchConfigs(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListSearchConfigsResponse r) {
        std::vector<google::cloud::visionai::v1::SearchConfig> result(
            r.search_configs().size());
        auto& messages = *r.mutable_search_configs();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseConnectionImpl::CreateSearchHypernym(
    google::cloud::visionai::v1::CreateSearchHypernymRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateSearchHypernym(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::CreateSearchHypernymRequest const&
                 request) {
        return stub_->CreateSearchHypernym(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseConnectionImpl::UpdateSearchHypernym(
    google::cloud::visionai::v1::UpdateSearchHypernymRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateSearchHypernym(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UpdateSearchHypernymRequest const&
                 request) {
        return stub_->UpdateSearchHypernym(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseConnectionImpl::GetSearchHypernym(
    google::cloud::visionai::v1::GetSearchHypernymRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetSearchHypernym(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GetSearchHypernymRequest const&
                 request) {
        return stub_->GetSearchHypernym(context, options, request);
      },
      *current, request, __func__);
}

Status WarehouseConnectionImpl::DeleteSearchHypernym(
    google::cloud::visionai::v1::DeleteSearchHypernymRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteSearchHypernym(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::DeleteSearchHypernymRequest const&
                 request) {
        return stub_->DeleteSearchHypernym(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::SearchHypernym>
WarehouseConnectionImpl::ListSearchHypernyms(
    google::cloud::visionai::v1::ListSearchHypernymsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListSearchHypernyms(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::SearchHypernym>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListSearchHypernymsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](
                grpc::ClientContext& context, Options const& options,
                google::cloud::visionai::v1::ListSearchHypernymsRequest const&
                    request) {
              return stub->ListSearchHypernyms(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListSearchHypernymsResponse r) {
        std::vector<google::cloud::visionai::v1::SearchHypernym> result(
            r.search_hypernyms().size());
        auto& messages = *r.mutable_search_hypernyms();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StreamRange<google::cloud::visionai::v1::SearchResultItem>
WarehouseConnectionImpl::SearchAssets(
    google::cloud::visionai::v1::SearchAssetsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->SearchAssets(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::SearchResultItem>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::SearchAssetsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::SearchAssetsRequest const&
                       request) {
              return stub->SearchAssets(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::SearchAssetsResponse r) {
        std::vector<google::cloud::visionai::v1::SearchResultItem> result(
            r.search_result_items().size());
        auto& messages = *r.mutable_search_result_items();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StreamRange<google::cloud::visionai::v1::SearchResultItem>
WarehouseConnectionImpl::SearchIndexEndpoint(
    google::cloud::visionai::v1::SearchIndexEndpointRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->SearchIndexEndpoint(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::SearchResultItem>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::SearchIndexEndpointRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](
                grpc::ClientContext& context, Options const& options,
                google::cloud::visionai::v1::SearchIndexEndpointRequest const&
                    request) {
              return stub->SearchIndexEndpoint(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::SearchIndexEndpointResponse r) {
        std::vector<google::cloud::visionai::v1::SearchResultItem> result(
            r.search_result_items().size());
        auto& messages = *r.mutable_search_result_items();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseConnectionImpl::CreateIndexEndpoint(
    google::cloud::visionai::v1::CreateIndexEndpointRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->CreateIndexEndpoint(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::IndexEndpoint>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::CreateIndexEndpointRequest const&
              request) {
        return stub->AsyncCreateIndexEndpoint(cq, std::move(context),
                                              std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::IndexEndpoint>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation>
WarehouseConnectionImpl::CreateIndexEndpoint(
    NoAwaitTag,
    google::cloud::visionai::v1::CreateIndexEndpointRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateIndexEndpoint(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::CreateIndexEndpointRequest const&
                 request) {
        return stub_->CreateIndexEndpoint(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseConnectionImpl::CreateIndexEndpoint(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::
                   CreateIndexEndpointMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::IndexEndpoint>>(
        internal::InvalidArgumentError(
            "operation does not correspond to CreateIndexEndpoint",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::IndexEndpoint>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::IndexEndpoint>,
      polling_policy(*current), __func__);
}

StatusOr<google::cloud::visionai::v1::IndexEndpoint>
WarehouseConnectionImpl::GetIndexEndpoint(
    google::cloud::visionai::v1::GetIndexEndpointRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetIndexEndpoint(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::GetIndexEndpointRequest const& request) {
        return stub_->GetIndexEndpoint(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::IndexEndpoint>
WarehouseConnectionImpl::ListIndexEndpoints(
    google::cloud::visionai::v1::ListIndexEndpointsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListIndexEndpoints(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::IndexEndpoint>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListIndexEndpointsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ListIndexEndpointsRequest const&
                       request) {
              return stub->ListIndexEndpoints(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListIndexEndpointsResponse r) {
        std::vector<google::cloud::visionai::v1::IndexEndpoint> result(
            r.index_endpoints().size());
        auto& messages = *r.mutable_index_endpoints();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseConnectionImpl::UpdateIndexEndpoint(
    google::cloud::visionai::v1::UpdateIndexEndpointRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->UpdateIndexEndpoint(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::IndexEndpoint>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::UpdateIndexEndpointRequest const&
              request) {
        return stub->AsyncUpdateIndexEndpoint(cq, std::move(context),
                                              std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::IndexEndpoint>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation>
WarehouseConnectionImpl::UpdateIndexEndpoint(
    NoAwaitTag,
    google::cloud::visionai::v1::UpdateIndexEndpointRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateIndexEndpoint(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UpdateIndexEndpointRequest const&
                 request) {
        return stub_->UpdateIndexEndpoint(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseConnectionImpl::UpdateIndexEndpoint(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::
                   UpdateIndexEndpointMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::IndexEndpoint>>(
        internal::InvalidArgumentError(
            "operation does not correspond to UpdateIndexEndpoint",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::IndexEndpoint>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::IndexEndpoint>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexEndpointMetadata>>
WarehouseConnectionImpl::DeleteIndexEndpoint(
    google::cloud::visionai::v1::DeleteIndexEndpointRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->DeleteIndexEndpoint(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::DeleteIndexEndpointMetadata>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::DeleteIndexEndpointRequest const&
              request) {
        return stub->AsyncDeleteIndexEndpoint(cq, std::move(context),
                                              std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteIndexEndpointMetadata>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation>
WarehouseConnectionImpl::DeleteIndexEndpoint(
    NoAwaitTag,
    google::cloud::visionai::v1::DeleteIndexEndpointRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteIndexEndpoint(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::DeleteIndexEndpointRequest const&
                 request) {
        return stub_->DeleteIndexEndpoint(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexEndpointMetadata>>
WarehouseConnectionImpl::DeleteIndexEndpoint(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::
                   DeleteIndexEndpointMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::DeleteIndexEndpointMetadata>>(
        internal::InvalidArgumentError(
            "operation does not correspond to DeleteIndexEndpoint",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::DeleteIndexEndpointMetadata>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteIndexEndpointMetadata>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeployIndexResponse>>
WarehouseConnectionImpl::DeployIndex(
    google::cloud::visionai::v1::DeployIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->DeployIndex(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::DeployIndexResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::DeployIndexRequest const& request) {
        return stub->AsyncDeployIndex(cq, std::move(context),
                                      std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::DeployIndexResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::DeployIndex(
    NoAwaitTag,
    google::cloud::visionai::v1::DeployIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeployIndex(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::DeployIndexRequest const& request) {
        return stub_->DeployIndex(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeployIndexResponse>>
WarehouseConnectionImpl::DeployIndex(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::DeployIndexMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::DeployIndexResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to DeployIndex",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::DeployIndexResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::DeployIndexResponse>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::UndeployIndexResponse>>
WarehouseConnectionImpl::UndeployIndex(
    google::cloud::visionai::v1::UndeployIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->UndeployIndex(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::UndeployIndexResponse>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::UndeployIndexRequest const& request) {
        return stub->AsyncUndeployIndex(cq, std::move(context),
                                        std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::UndeployIndexResponse>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::UndeployIndex(
    NoAwaitTag,
    google::cloud::visionai::v1::UndeployIndexRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UndeployIndex(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::UndeployIndexRequest const& request) {
        return stub_->UndeployIndex(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::UndeployIndexResponse>>
WarehouseConnectionImpl::UndeployIndex(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::UndeployIndexMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::UndeployIndexResponse>>(
        internal::InvalidArgumentError(
            "operation does not correspond to UndeployIndex",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::UndeployIndexResponse>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::UndeployIndexResponse>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::Collection>>
WarehouseConnectionImpl::CreateCollection(
    google::cloud::visionai::v1::CreateCollectionRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->CreateCollection(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::Collection>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::CreateCollectionRequest const& request) {
        return stub->AsyncCreateCollection(cq, std::move(context),
                                           std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Collection>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation>
WarehouseConnectionImpl::CreateCollection(
    NoAwaitTag,
    google::cloud::visionai::v1::CreateCollectionRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CreateCollection(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::CreateCollectionRequest const& request) {
        return stub_->CreateCollection(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::Collection>>
WarehouseConnectionImpl::CreateCollection(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::
                   CreateCollectionMetadata>()) {
    return make_ready_future<StatusOr<google::cloud::visionai::v1::Collection>>(
        internal::InvalidArgumentError(
            "operation does not correspond to CreateCollection",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::Collection>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultResponse<
          google::cloud::visionai::v1::Collection>,
      polling_policy(*current), __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeleteCollectionMetadata>>
WarehouseConnectionImpl::DeleteCollection(
    google::cloud::visionai::v1::DeleteCollectionRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto request_copy = request;
  auto const idempotent =
      idempotency_policy(*current)->DeleteCollection(request_copy);
  return google::cloud::internal::AsyncLongRunningOperation<
      google::cloud::visionai::v1::DeleteCollectionMetadata>(
      background_->cq(), current, std::move(request_copy),
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::cloud::visionai::v1::DeleteCollectionRequest const& request) {
        return stub->AsyncDeleteCollection(cq, std::move(context),
                                           std::move(options), request);
      },
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteCollectionMetadata>,
      retry_policy(*current), backoff_policy(*current), idempotent,
      polling_policy(*current), __func__);
}

StatusOr<google::longrunning::Operation>
WarehouseConnectionImpl::DeleteCollection(
    NoAwaitTag,
    google::cloud::visionai::v1::DeleteCollectionRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteCollection(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::DeleteCollectionRequest const& request) {
        return stub_->DeleteCollection(context, options, request);
      },
      *current, request, __func__);
}

future<StatusOr<google::cloud::visionai::v1::DeleteCollectionMetadata>>
WarehouseConnectionImpl::DeleteCollection(
    google::longrunning::Operation const& operation) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  if (!operation.metadata()
           .Is<typename google::cloud::visionai::v1::
                   DeleteCollectionMetadata>()) {
    return make_ready_future<
        StatusOr<google::cloud::visionai::v1::DeleteCollectionMetadata>>(
        internal::InvalidArgumentError(
            "operation does not correspond to DeleteCollection",
            GCP_ERROR_INFO().WithMetadata("operation",
                                          operation.metadata().DebugString())));
  }

  return google::cloud::internal::AsyncAwaitLongRunningOperation<
      google::cloud::visionai::v1::DeleteCollectionMetadata>(
      background_->cq(), current, operation,
      [stub = stub_](google::cloud::CompletionQueue& cq,
                     std::shared_ptr<grpc::ClientContext> context,
                     google::cloud::internal::ImmutableOptions options,
                     google::longrunning::GetOperationRequest const& request) {
        return stub->AsyncGetOperation(cq, std::move(context),
                                       std::move(options), request);
      },
      [stub = stub_](
          google::cloud::CompletionQueue& cq,
          std::shared_ptr<grpc::ClientContext> context,
          google::cloud::internal::ImmutableOptions options,
          google::longrunning::CancelOperationRequest const& request) {
        return stub->AsyncCancelOperation(cq, std::move(context),
                                          std::move(options), request);
      },
      &google::cloud::internal::ExtractLongRunningResultMetadata<
          google::cloud::visionai::v1::DeleteCollectionMetadata>,
      polling_policy(*current), __func__);
}

StatusOr<google::cloud::visionai::v1::Collection>
WarehouseConnectionImpl::GetCollection(
    google::cloud::visionai::v1::GetCollectionRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetCollection(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::GetCollectionRequest const& request) {
        return stub_->GetCollection(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::Collection>
WarehouseConnectionImpl::UpdateCollection(
    google::cloud::visionai::v1::UpdateCollectionRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->UpdateCollection(request),
      [this](
          grpc::ClientContext& context, Options const& options,
          google::cloud::visionai::v1::UpdateCollectionRequest const& request) {
        return stub_->UpdateCollection(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::Collection>
WarehouseConnectionImpl::ListCollections(
    google::cloud::visionai::v1::ListCollectionsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListCollections(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::Collection>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ListCollectionsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::cloud::visionai::v1::ListCollectionsRequest const&
                       request) {
              return stub->ListCollections(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ListCollectionsResponse r) {
        std::vector<google::cloud::visionai::v1::Collection> result(
            r.collections().size());
        auto& messages = *r.mutable_collections();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StatusOr<google::cloud::visionai::v1::AddCollectionItemResponse>
WarehouseConnectionImpl::AddCollectionItem(
    google::cloud::visionai::v1::AddCollectionItemRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->AddCollectionItem(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::AddCollectionItemRequest const&
                 request) {
        return stub_->AddCollectionItem(context, options, request);
      },
      *current, request, __func__);
}

StatusOr<google::cloud::visionai::v1::RemoveCollectionItemResponse>
WarehouseConnectionImpl::RemoveCollectionItem(
    google::cloud::visionai::v1::RemoveCollectionItemRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->RemoveCollectionItem(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::visionai::v1::RemoveCollectionItemRequest const&
                 request) {
        return stub_->RemoveCollectionItem(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::cloud::visionai::v1::CollectionItem>
WarehouseConnectionImpl::ViewCollectionItems(
    google::cloud::visionai::v1::ViewCollectionItemsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ViewCollectionItems(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::visionai::v1::CollectionItem>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::visionai::v1::ViewCollectionItemsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](
                grpc::ClientContext& context, Options const& options,
                google::cloud::visionai::v1::ViewCollectionItemsRequest const&
                    request) {
              return stub->ViewCollectionItems(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::visionai::v1::ViewCollectionItemsResponse r) {
        std::vector<google::cloud::visionai::v1::CollectionItem> result(
            r.items().size());
        auto& messages = *r.mutable_items();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StreamRange<google::cloud::location::Location>
WarehouseConnectionImpl::ListLocations(
    google::cloud::location::ListLocationsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListLocations(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::cloud::location::Location>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::cloud::location::ListLocationsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](
                grpc::ClientContext& context, Options const& options,
                google::cloud::location::ListLocationsRequest const& request) {
              return stub->ListLocations(context, options, request);
            },
            options, r, function_name);
      },
      [](google::cloud::location::ListLocationsResponse r) {
        std::vector<google::cloud::location::Location> result(
            r.locations().size());
        auto& messages = *r.mutable_locations();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StatusOr<google::cloud::location::Location>
WarehouseConnectionImpl::GetLocation(
    google::cloud::location::GetLocationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetLocation(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::cloud::location::GetLocationRequest const& request) {
        return stub_->GetLocation(context, options, request);
      },
      *current, request, __func__);
}

StreamRange<google::longrunning::Operation>
WarehouseConnectionImpl::ListOperations(
    google::longrunning::ListOperationsRequest request) {
  request.clear_page_token();
  auto current = google::cloud::internal::SaveCurrentOptions();
  auto idempotency = idempotency_policy(*current)->ListOperations(request);
  char const* function_name = __func__;
  return google::cloud::internal::MakePaginationRange<
      StreamRange<google::longrunning::Operation>>(
      current, std::move(request),
      [idempotency, function_name, stub = stub_,
       retry = std::shared_ptr<visionai_v1::WarehouseRetryPolicy>(
           retry_policy(*current)),
       backoff = std::shared_ptr<BackoffPolicy>(backoff_policy(*current))](
          Options const& options,
          google::longrunning::ListOperationsRequest const& r) {
        return google::cloud::internal::RetryLoop(
            retry->clone(), backoff->clone(), idempotency,
            [stub](grpc::ClientContext& context, Options const& options,
                   google::longrunning::ListOperationsRequest const& request) {
              return stub->ListOperations(context, options, request);
            },
            options, r, function_name);
      },
      [](google::longrunning::ListOperationsResponse r) {
        std::vector<google::longrunning::Operation> result(
            r.operations().size());
        auto& messages = *r.mutable_operations();
        std::move(messages.begin(), messages.end(), result.begin());
        return result;
      });
}

StatusOr<google::longrunning::Operation> WarehouseConnectionImpl::GetOperation(
    google::longrunning::GetOperationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->GetOperation(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::longrunning::GetOperationRequest const& request) {
        return stub_->GetOperation(context, options, request);
      },
      *current, request, __func__);
}

Status WarehouseConnectionImpl::DeleteOperation(
    google::longrunning::DeleteOperationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->DeleteOperation(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::longrunning::DeleteOperationRequest const& request) {
        return stub_->DeleteOperation(context, options, request);
      },
      *current, request, __func__);
}

Status WarehouseConnectionImpl::CancelOperation(
    google::longrunning::CancelOperationRequest const& request) {
  auto current = google::cloud::internal::SaveCurrentOptions();
  return google::cloud::internal::RetryLoop(
      retry_policy(*current), backoff_policy(*current),
      idempotency_policy(*current)->CancelOperation(request),
      [this](grpc::ClientContext& context, Options const& options,
             google::longrunning::CancelOperationRequest const& request) {
        return stub_->CancelOperation(context, options, request);
      },
      *current, request, __func__);
}

GOOGLE_CLOUD_CPP_INLINE_NAMESPACE_END
}  // namespace visionai_v1_internal
}  // namespace cloud
}  // namespace google

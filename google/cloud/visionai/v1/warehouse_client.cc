// Copyright 2026 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the Codegen C++ plugin.
// If you make any local changes, they will be lost.
// source: google/cloud/visionai/v1/warehouse.proto

#include "google/cloud/visionai/v1/warehouse_client.h"
#include <memory>
#include <utility>

namespace google {
namespace cloud {
namespace visionai_v1 {
GOOGLE_CLOUD_CPP_INLINE_NAMESPACE_BEGIN

WarehouseClient::WarehouseClient(
    std::shared_ptr<WarehouseConnection> connection, Options opts)
    : connection_(std::move(connection)),
      options_(
          internal::MergeOptions(std::move(opts), connection_->options())) {}
WarehouseClient::~WarehouseClient() = default;

StatusOr<google::cloud::visionai::v1::Asset> WarehouseClient::CreateAsset(
    std::string const& parent, google::cloud::visionai::v1::Asset const& asset,
    std::string const& asset_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateAssetRequest request;
  request.set_parent(parent);
  *request.mutable_asset() = asset;
  request.set_asset_id(asset_id);
  return connection_->CreateAsset(request);
}

StatusOr<google::cloud::visionai::v1::Asset> WarehouseClient::CreateAsset(
    google::cloud::visionai::v1::CreateAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateAsset(request);
}

StatusOr<google::cloud::visionai::v1::Asset> WarehouseClient::UpdateAsset(
    google::cloud::visionai::v1::Asset const& asset,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateAssetRequest request;
  *request.mutable_asset() = asset;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateAsset(request);
}

StatusOr<google::cloud::visionai::v1::Asset> WarehouseClient::UpdateAsset(
    google::cloud::visionai::v1::UpdateAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateAsset(request);
}

StatusOr<google::cloud::visionai::v1::Asset> WarehouseClient::GetAsset(
    std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetAssetRequest request;
  request.set_name(name);
  return connection_->GetAsset(request);
}

StatusOr<google::cloud::visionai::v1::Asset> WarehouseClient::GetAsset(
    google::cloud::visionai::v1::GetAssetRequest const& request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetAsset(request);
}

StreamRange<google::cloud::visionai::v1::Asset> WarehouseClient::ListAssets(
    std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListAssetsRequest request;
  request.set_parent(parent);
  return connection_->ListAssets(request);
}

StreamRange<google::cloud::visionai::v1::Asset> WarehouseClient::ListAssets(
    google::cloud::visionai::v1::ListAssetsRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListAssets(std::move(request));
}

future<StatusOr<google::cloud::visionai::v1::DeleteAssetMetadata>>
WarehouseClient::DeleteAsset(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteAssetRequest request;
  request.set_name(name);
  return connection_->DeleteAsset(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteAsset(
    NoAwaitTag, std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteAssetRequest request;
  request.set_name(name);
  return connection_->DeleteAsset(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteAssetMetadata>>
WarehouseClient::DeleteAsset(
    google::cloud::visionai::v1::DeleteAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteAsset(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteAsset(
    NoAwaitTag, google::cloud::visionai::v1::DeleteAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteAsset(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteAssetMetadata>>
WarehouseClient::DeleteAsset(google::longrunning::Operation const& operation,
                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteAsset(operation);
}

future<StatusOr<google::cloud::visionai::v1::UploadAssetResponse>>
WarehouseClient::UploadAsset(
    google::cloud::visionai::v1::UploadAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UploadAsset(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::UploadAsset(
    NoAwaitTag, google::cloud::visionai::v1::UploadAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UploadAsset(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::UploadAssetResponse>>
WarehouseClient::UploadAsset(google::longrunning::Operation const& operation,
                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UploadAsset(operation);
}

StatusOr<google::cloud::visionai::v1::GenerateRetrievalUrlResponse>
WarehouseClient::GenerateRetrievalUrl(
    google::cloud::visionai::v1::GenerateRetrievalUrlRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GenerateRetrievalUrl(request);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeAssetResponse>>
WarehouseClient::AnalyzeAsset(
    google::cloud::visionai::v1::AnalyzeAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AnalyzeAsset(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::AnalyzeAsset(
    NoAwaitTag, google::cloud::visionai::v1::AnalyzeAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AnalyzeAsset(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeAssetResponse>>
WarehouseClient::AnalyzeAsset(google::longrunning::Operation const& operation,
                              Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AnalyzeAsset(operation);
}

future<StatusOr<google::cloud::visionai::v1::IndexAssetResponse>>
WarehouseClient::IndexAsset(
    google::cloud::visionai::v1::IndexAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->IndexAsset(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::IndexAsset(
    NoAwaitTag, google::cloud::visionai::v1::IndexAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->IndexAsset(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::IndexAssetResponse>>
WarehouseClient::IndexAsset(google::longrunning::Operation const& operation,
                            Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->IndexAsset(operation);
}

future<StatusOr<google::cloud::visionai::v1::RemoveIndexAssetResponse>>
WarehouseClient::RemoveIndexAsset(
    google::cloud::visionai::v1::RemoveIndexAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->RemoveIndexAsset(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::RemoveIndexAsset(
    NoAwaitTag,
    google::cloud::visionai::v1::RemoveIndexAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->RemoveIndexAsset(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::RemoveIndexAssetResponse>>
WarehouseClient::RemoveIndexAsset(
    google::longrunning::Operation const& operation, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->RemoveIndexAsset(operation);
}

StreamRange<google::cloud::visionai::v1::IndexedAsset>
WarehouseClient::ViewIndexedAssets(std::string const& index, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ViewIndexedAssetsRequest request;
  request.set_index(index);
  return connection_->ViewIndexedAssets(request);
}

StreamRange<google::cloud::visionai::v1::IndexedAsset>
WarehouseClient::ViewIndexedAssets(
    google::cloud::visionai::v1::ViewIndexedAssetsRequest request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ViewIndexedAssets(std::move(request));
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseClient::CreateIndex(std::string const& parent,
                             google::cloud::visionai::v1::Index const& index,
                             std::string const& index_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateIndexRequest request;
  request.set_parent(parent);
  *request.mutable_index() = index;
  request.set_index_id(index_id);
  return connection_->CreateIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateIndex(
    NoAwaitTag, std::string const& parent,
    google::cloud::visionai::v1::Index const& index,
    std::string const& index_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateIndexRequest request;
  request.set_parent(parent);
  *request.mutable_index() = index;
  request.set_index_id(index_id);
  return connection_->CreateIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseClient::CreateIndex(
    google::cloud::visionai::v1::CreateIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateIndex(
    NoAwaitTag, google::cloud::visionai::v1::CreateIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseClient::CreateIndex(google::longrunning::Operation const& operation,
                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateIndex(operation);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseClient::UpdateIndex(google::cloud::visionai::v1::Index const& index,
                             google::protobuf::FieldMask const& update_mask,
                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateIndexRequest request;
  *request.mutable_index() = index;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::UpdateIndex(
    NoAwaitTag, google::cloud::visionai::v1::Index const& index,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateIndexRequest request;
  *request.mutable_index() = index;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseClient::UpdateIndex(
    google::cloud::visionai::v1::UpdateIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::UpdateIndex(
    NoAwaitTag, google::cloud::visionai::v1::UpdateIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Index>>
WarehouseClient::UpdateIndex(google::longrunning::Operation const& operation,
                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateIndex(operation);
}

StatusOr<google::cloud::visionai::v1::Index> WarehouseClient::GetIndex(
    std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetIndexRequest request;
  request.set_name(name);
  return connection_->GetIndex(request);
}

StatusOr<google::cloud::visionai::v1::Index> WarehouseClient::GetIndex(
    google::cloud::visionai::v1::GetIndexRequest const& request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetIndex(request);
}

StreamRange<google::cloud::visionai::v1::Index> WarehouseClient::ListIndexes(
    std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListIndexesRequest request;
  request.set_parent(parent);
  return connection_->ListIndexes(request);
}

StreamRange<google::cloud::visionai::v1::Index> WarehouseClient::ListIndexes(
    google::cloud::visionai::v1::ListIndexesRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListIndexes(std::move(request));
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexMetadata>>
WarehouseClient::DeleteIndex(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteIndexRequest request;
  request.set_name(name);
  return connection_->DeleteIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteIndex(
    NoAwaitTag, std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteIndexRequest request;
  request.set_name(name);
  return connection_->DeleteIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexMetadata>>
WarehouseClient::DeleteIndex(
    google::cloud::visionai::v1::DeleteIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteIndex(
    NoAwaitTag, google::cloud::visionai::v1::DeleteIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexMetadata>>
WarehouseClient::DeleteIndex(google::longrunning::Operation const& operation,
                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteIndex(operation);
}

future<StatusOr<google::cloud::visionai::v1::Corpus>>
WarehouseClient::CreateCorpus(std::string const& parent,
                              google::cloud::visionai::v1::Corpus const& corpus,
                              Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateCorpusRequest request;
  request.set_parent(parent);
  *request.mutable_corpus() = corpus;
  return connection_->CreateCorpus(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateCorpus(
    NoAwaitTag, std::string const& parent,
    google::cloud::visionai::v1::Corpus const& corpus, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateCorpusRequest request;
  request.set_parent(parent);
  *request.mutable_corpus() = corpus;
  return connection_->CreateCorpus(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Corpus>>
WarehouseClient::CreateCorpus(
    google::cloud::visionai::v1::CreateCorpusRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateCorpus(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateCorpus(
    NoAwaitTag, google::cloud::visionai::v1::CreateCorpusRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateCorpus(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Corpus>>
WarehouseClient::CreateCorpus(google::longrunning::Operation const& operation,
                              Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateCorpus(operation);
}

StatusOr<google::cloud::visionai::v1::Corpus> WarehouseClient::GetCorpus(
    std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetCorpusRequest request;
  request.set_name(name);
  return connection_->GetCorpus(request);
}

StatusOr<google::cloud::visionai::v1::Corpus> WarehouseClient::GetCorpus(
    google::cloud::visionai::v1::GetCorpusRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetCorpus(request);
}

StatusOr<google::cloud::visionai::v1::Corpus> WarehouseClient::UpdateCorpus(
    google::cloud::visionai::v1::Corpus const& corpus,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateCorpusRequest request;
  *request.mutable_corpus() = corpus;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateCorpus(request);
}

StatusOr<google::cloud::visionai::v1::Corpus> WarehouseClient::UpdateCorpus(
    google::cloud::visionai::v1::UpdateCorpusRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateCorpus(request);
}

StreamRange<google::cloud::visionai::v1::Corpus> WarehouseClient::ListCorpora(
    std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListCorporaRequest request;
  request.set_parent(parent);
  return connection_->ListCorpora(request);
}

StreamRange<google::cloud::visionai::v1::Corpus> WarehouseClient::ListCorpora(
    google::cloud::visionai::v1::ListCorporaRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListCorpora(std::move(request));
}

Status WarehouseClient::DeleteCorpus(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteCorpusRequest request;
  request.set_name(name);
  return connection_->DeleteCorpus(request);
}

Status WarehouseClient::DeleteCorpus(
    google::cloud::visionai::v1::DeleteCorpusRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteCorpus(request);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeCorpusResponse>>
WarehouseClient::AnalyzeCorpus(
    google::cloud::visionai::v1::AnalyzeCorpusRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AnalyzeCorpus(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::AnalyzeCorpus(
    NoAwaitTag,
    google::cloud::visionai::v1::AnalyzeCorpusRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AnalyzeCorpus(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::AnalyzeCorpusResponse>>
WarehouseClient::AnalyzeCorpus(google::longrunning::Operation const& operation,
                               Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AnalyzeCorpus(operation);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseClient::CreateDataSchema(
    std::string const& parent,
    google::cloud::visionai::v1::DataSchema const& data_schema, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateDataSchemaRequest request;
  request.set_parent(parent);
  *request.mutable_data_schema() = data_schema;
  return connection_->CreateDataSchema(request);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseClient::CreateDataSchema(
    google::cloud::visionai::v1::CreateDataSchemaRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateDataSchema(request);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseClient::UpdateDataSchema(
    google::cloud::visionai::v1::DataSchema const& data_schema,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateDataSchemaRequest request;
  *request.mutable_data_schema() = data_schema;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateDataSchema(request);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseClient::UpdateDataSchema(
    google::cloud::visionai::v1::UpdateDataSchemaRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateDataSchema(request);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseClient::GetDataSchema(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetDataSchemaRequest request;
  request.set_name(name);
  return connection_->GetDataSchema(request);
}

StatusOr<google::cloud::visionai::v1::DataSchema>
WarehouseClient::GetDataSchema(
    google::cloud::visionai::v1::GetDataSchemaRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetDataSchema(request);
}

Status WarehouseClient::DeleteDataSchema(std::string const& name,
                                         Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteDataSchemaRequest request;
  request.set_name(name);
  return connection_->DeleteDataSchema(request);
}

Status WarehouseClient::DeleteDataSchema(
    google::cloud::visionai::v1::DeleteDataSchemaRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteDataSchema(request);
}

StreamRange<google::cloud::visionai::v1::DataSchema>
WarehouseClient::ListDataSchemas(std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListDataSchemasRequest request;
  request.set_parent(parent);
  return connection_->ListDataSchemas(request);
}

StreamRange<google::cloud::visionai::v1::DataSchema>
WarehouseClient::ListDataSchemas(
    google::cloud::visionai::v1::ListDataSchemasRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListDataSchemas(std::move(request));
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseClient::CreateAnnotation(
    std::string const& parent,
    google::cloud::visionai::v1::Annotation const& annotation,
    std::string const& annotation_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateAnnotationRequest request;
  request.set_parent(parent);
  *request.mutable_annotation() = annotation;
  request.set_annotation_id(annotation_id);
  return connection_->CreateAnnotation(request);
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseClient::CreateAnnotation(
    google::cloud::visionai::v1::CreateAnnotationRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateAnnotation(request);
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseClient::GetAnnotation(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetAnnotationRequest request;
  request.set_name(name);
  return connection_->GetAnnotation(request);
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseClient::GetAnnotation(
    google::cloud::visionai::v1::GetAnnotationRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetAnnotation(request);
}

StreamRange<google::cloud::visionai::v1::Annotation>
WarehouseClient::ListAnnotations(std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListAnnotationsRequest request;
  request.set_parent(parent);
  return connection_->ListAnnotations(request);
}

StreamRange<google::cloud::visionai::v1::Annotation>
WarehouseClient::ListAnnotations(
    google::cloud::visionai::v1::ListAnnotationsRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListAnnotations(std::move(request));
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseClient::UpdateAnnotation(
    google::cloud::visionai::v1::Annotation const& annotation,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateAnnotationRequest request;
  *request.mutable_annotation() = annotation;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateAnnotation(request);
}

StatusOr<google::cloud::visionai::v1::Annotation>
WarehouseClient::UpdateAnnotation(
    google::cloud::visionai::v1::UpdateAnnotationRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateAnnotation(request);
}

Status WarehouseClient::DeleteAnnotation(std::string const& name,
                                         Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteAnnotationRequest request;
  request.set_name(name);
  return connection_->DeleteAnnotation(request);
}

Status WarehouseClient::DeleteAnnotation(
    google::cloud::visionai::v1::DeleteAnnotationRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteAnnotation(request);
}

std::unique_ptr<::google::cloud::AsyncStreamingReadWriteRpc<
    google::cloud::visionai::v1::IngestAssetRequest,
    google::cloud::visionai::v1::IngestAssetResponse>>
WarehouseClient::AsyncIngestAsset(Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AsyncIngestAsset();
}

StatusOr<google::cloud::visionai::v1::ClipAssetResponse>
WarehouseClient::ClipAsset(
    google::cloud::visionai::v1::ClipAssetRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ClipAsset(request);
}

StatusOr<google::cloud::visionai::v1::GenerateHlsUriResponse>
WarehouseClient::GenerateHlsUri(
    google::cloud::visionai::v1::GenerateHlsUriRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GenerateHlsUri(request);
}

future<StatusOr<google::cloud::visionai::v1::ImportAssetsResponse>>
WarehouseClient::ImportAssets(
    google::cloud::visionai::v1::ImportAssetsRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ImportAssets(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::ImportAssets(
    NoAwaitTag, google::cloud::visionai::v1::ImportAssetsRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ImportAssets(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::ImportAssetsResponse>>
WarehouseClient::ImportAssets(google::longrunning::Operation const& operation,
                              Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ImportAssets(operation);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::CreateSearchConfig(
    std::string const& parent,
    google::cloud::visionai::v1::SearchConfig const& search_config,
    std::string const& search_config_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateSearchConfigRequest request;
  request.set_parent(parent);
  *request.mutable_search_config() = search_config;
  request.set_search_config_id(search_config_id);
  return connection_->CreateSearchConfig(request);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::CreateSearchConfig(
    google::cloud::visionai::v1::CreateSearchConfigRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateSearchConfig(request);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::UpdateSearchConfig(
    google::cloud::visionai::v1::SearchConfig const& search_config,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateSearchConfigRequest request;
  *request.mutable_search_config() = search_config;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateSearchConfig(request);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::UpdateSearchConfig(
    google::cloud::visionai::v1::UpdateSearchConfigRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateSearchConfig(request);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::GetSearchConfig(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetSearchConfigRequest request;
  request.set_name(name);
  return connection_->GetSearchConfig(request);
}

StatusOr<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::GetSearchConfig(
    google::cloud::visionai::v1::GetSearchConfigRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetSearchConfig(request);
}

Status WarehouseClient::DeleteSearchConfig(std::string const& name,
                                           Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteSearchConfigRequest request;
  request.set_name(name);
  return connection_->DeleteSearchConfig(request);
}

Status WarehouseClient::DeleteSearchConfig(
    google::cloud::visionai::v1::DeleteSearchConfigRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteSearchConfig(request);
}

StreamRange<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::ListSearchConfigs(std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListSearchConfigsRequest request;
  request.set_parent(parent);
  return connection_->ListSearchConfigs(request);
}

StreamRange<google::cloud::visionai::v1::SearchConfig>
WarehouseClient::ListSearchConfigs(
    google::cloud::visionai::v1::ListSearchConfigsRequest request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListSearchConfigs(std::move(request));
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::CreateSearchHypernym(
    std::string const& parent,
    google::cloud::visionai::v1::SearchHypernym const& search_hypernym,
    std::string const& search_hypernym_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateSearchHypernymRequest request;
  request.set_parent(parent);
  *request.mutable_search_hypernym() = search_hypernym;
  request.set_search_hypernym_id(search_hypernym_id);
  return connection_->CreateSearchHypernym(request);
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::CreateSearchHypernym(
    google::cloud::visionai::v1::CreateSearchHypernymRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateSearchHypernym(request);
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::UpdateSearchHypernym(
    google::cloud::visionai::v1::SearchHypernym const& search_hypernym,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateSearchHypernymRequest request;
  *request.mutable_search_hypernym() = search_hypernym;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateSearchHypernym(request);
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::UpdateSearchHypernym(
    google::cloud::visionai::v1::UpdateSearchHypernymRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateSearchHypernym(request);
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::GetSearchHypernym(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetSearchHypernymRequest request;
  request.set_name(name);
  return connection_->GetSearchHypernym(request);
}

StatusOr<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::GetSearchHypernym(
    google::cloud::visionai::v1::GetSearchHypernymRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetSearchHypernym(request);
}

Status WarehouseClient::DeleteSearchHypernym(std::string const& name,
                                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteSearchHypernymRequest request;
  request.set_name(name);
  return connection_->DeleteSearchHypernym(request);
}

Status WarehouseClient::DeleteSearchHypernym(
    google::cloud::visionai::v1::DeleteSearchHypernymRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteSearchHypernym(request);
}

StreamRange<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::ListSearchHypernyms(std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListSearchHypernymsRequest request;
  request.set_parent(parent);
  return connection_->ListSearchHypernyms(request);
}

StreamRange<google::cloud::visionai::v1::SearchHypernym>
WarehouseClient::ListSearchHypernyms(
    google::cloud::visionai::v1::ListSearchHypernymsRequest request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListSearchHypernyms(std::move(request));
}

StreamRange<google::cloud::visionai::v1::SearchResultItem>
WarehouseClient::SearchAssets(
    google::cloud::visionai::v1::SearchAssetsRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->SearchAssets(std::move(request));
}

StreamRange<google::cloud::visionai::v1::SearchResultItem>
WarehouseClient::SearchIndexEndpoint(
    google::cloud::visionai::v1::SearchIndexEndpointRequest request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->SearchIndexEndpoint(std::move(request));
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseClient::CreateIndexEndpoint(
    std::string const& parent,
    google::cloud::visionai::v1::IndexEndpoint const& index_endpoint,
    std::string const& index_endpoint_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateIndexEndpointRequest request;
  request.set_parent(parent);
  *request.mutable_index_endpoint() = index_endpoint;
  request.set_index_endpoint_id(index_endpoint_id);
  return connection_->CreateIndexEndpoint(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateIndexEndpoint(
    NoAwaitTag, std::string const& parent,
    google::cloud::visionai::v1::IndexEndpoint const& index_endpoint,
    std::string const& index_endpoint_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateIndexEndpointRequest request;
  request.set_parent(parent);
  *request.mutable_index_endpoint() = index_endpoint;
  request.set_index_endpoint_id(index_endpoint_id);
  return connection_->CreateIndexEndpoint(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseClient::CreateIndexEndpoint(
    google::cloud::visionai::v1::CreateIndexEndpointRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateIndexEndpoint(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateIndexEndpoint(
    NoAwaitTag,
    google::cloud::visionai::v1::CreateIndexEndpointRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateIndexEndpoint(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseClient::CreateIndexEndpoint(
    google::longrunning::Operation const& operation, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateIndexEndpoint(operation);
}

StatusOr<google::cloud::visionai::v1::IndexEndpoint>
WarehouseClient::GetIndexEndpoint(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetIndexEndpointRequest request;
  request.set_name(name);
  return connection_->GetIndexEndpoint(request);
}

StatusOr<google::cloud::visionai::v1::IndexEndpoint>
WarehouseClient::GetIndexEndpoint(
    google::cloud::visionai::v1::GetIndexEndpointRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetIndexEndpoint(request);
}

StreamRange<google::cloud::visionai::v1::IndexEndpoint>
WarehouseClient::ListIndexEndpoints(std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListIndexEndpointsRequest request;
  request.set_parent(parent);
  return connection_->ListIndexEndpoints(request);
}

StreamRange<google::cloud::visionai::v1::IndexEndpoint>
WarehouseClient::ListIndexEndpoints(
    google::cloud::visionai::v1::ListIndexEndpointsRequest request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListIndexEndpoints(std::move(request));
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseClient::UpdateIndexEndpoint(
    google::cloud::visionai::v1::IndexEndpoint const& index_endpoint,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateIndexEndpointRequest request;
  *request.mutable_index_endpoint() = index_endpoint;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateIndexEndpoint(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::UpdateIndexEndpoint(
    NoAwaitTag,
    google::cloud::visionai::v1::IndexEndpoint const& index_endpoint,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateIndexEndpointRequest request;
  *request.mutable_index_endpoint() = index_endpoint;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateIndexEndpoint(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseClient::UpdateIndexEndpoint(
    google::cloud::visionai::v1::UpdateIndexEndpointRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateIndexEndpoint(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::UpdateIndexEndpoint(
    NoAwaitTag,
    google::cloud::visionai::v1::UpdateIndexEndpointRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateIndexEndpoint(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::IndexEndpoint>>
WarehouseClient::UpdateIndexEndpoint(
    google::longrunning::Operation const& operation, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateIndexEndpoint(operation);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexEndpointMetadata>>
WarehouseClient::DeleteIndexEndpoint(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteIndexEndpointRequest request;
  request.set_name(name);
  return connection_->DeleteIndexEndpoint(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteIndexEndpoint(
    NoAwaitTag, std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteIndexEndpointRequest request;
  request.set_name(name);
  return connection_->DeleteIndexEndpoint(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexEndpointMetadata>>
WarehouseClient::DeleteIndexEndpoint(
    google::cloud::visionai::v1::DeleteIndexEndpointRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteIndexEndpoint(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteIndexEndpoint(
    NoAwaitTag,
    google::cloud::visionai::v1::DeleteIndexEndpointRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteIndexEndpoint(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteIndexEndpointMetadata>>
WarehouseClient::DeleteIndexEndpoint(
    google::longrunning::Operation const& operation, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteIndexEndpoint(operation);
}

future<StatusOr<google::cloud::visionai::v1::DeployIndexResponse>>
WarehouseClient::DeployIndex(
    google::cloud::visionai::v1::DeployIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeployIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeployIndex(
    NoAwaitTag, google::cloud::visionai::v1::DeployIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeployIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeployIndexResponse>>
WarehouseClient::DeployIndex(google::longrunning::Operation const& operation,
                             Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeployIndex(operation);
}

future<StatusOr<google::cloud::visionai::v1::UndeployIndexResponse>>
WarehouseClient::UndeployIndex(
    google::cloud::visionai::v1::UndeployIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UndeployIndex(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::UndeployIndex(
    NoAwaitTag,
    google::cloud::visionai::v1::UndeployIndexRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UndeployIndex(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::UndeployIndexResponse>>
WarehouseClient::UndeployIndex(google::longrunning::Operation const& operation,
                               Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UndeployIndex(operation);
}

future<StatusOr<google::cloud::visionai::v1::Collection>>
WarehouseClient::CreateCollection(
    std::string const& parent,
    google::cloud::visionai::v1::Collection const& collection,
    std::string const& collection_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateCollectionRequest request;
  request.set_parent(parent);
  *request.mutable_collection() = collection;
  request.set_collection_id(collection_id);
  return connection_->CreateCollection(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateCollection(
    NoAwaitTag, std::string const& parent,
    google::cloud::visionai::v1::Collection const& collection,
    std::string const& collection_id, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::CreateCollectionRequest request;
  request.set_parent(parent);
  *request.mutable_collection() = collection;
  request.set_collection_id(collection_id);
  return connection_->CreateCollection(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Collection>>
WarehouseClient::CreateCollection(
    google::cloud::visionai::v1::CreateCollectionRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateCollection(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::CreateCollection(
    NoAwaitTag,
    google::cloud::visionai::v1::CreateCollectionRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateCollection(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::Collection>>
WarehouseClient::CreateCollection(
    google::longrunning::Operation const& operation, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CreateCollection(operation);
}

future<StatusOr<google::cloud::visionai::v1::DeleteCollectionMetadata>>
WarehouseClient::DeleteCollection(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteCollectionRequest request;
  request.set_name(name);
  return connection_->DeleteCollection(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteCollection(
    NoAwaitTag, std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::DeleteCollectionRequest request;
  request.set_name(name);
  return connection_->DeleteCollection(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteCollectionMetadata>>
WarehouseClient::DeleteCollection(
    google::cloud::visionai::v1::DeleteCollectionRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteCollection(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::DeleteCollection(
    NoAwaitTag,
    google::cloud::visionai::v1::DeleteCollectionRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteCollection(NoAwaitTag{}, request);
}

future<StatusOr<google::cloud::visionai::v1::DeleteCollectionMetadata>>
WarehouseClient::DeleteCollection(
    google::longrunning::Operation const& operation, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteCollection(operation);
}

StatusOr<google::cloud::visionai::v1::Collection>
WarehouseClient::GetCollection(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::GetCollectionRequest request;
  request.set_name(name);
  return connection_->GetCollection(request);
}

StatusOr<google::cloud::visionai::v1::Collection>
WarehouseClient::GetCollection(
    google::cloud::visionai::v1::GetCollectionRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetCollection(request);
}

StatusOr<google::cloud::visionai::v1::Collection>
WarehouseClient::UpdateCollection(
    google::cloud::visionai::v1::Collection const& collection,
    google::protobuf::FieldMask const& update_mask, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::UpdateCollectionRequest request;
  *request.mutable_collection() = collection;
  *request.mutable_update_mask() = update_mask;
  return connection_->UpdateCollection(request);
}

StatusOr<google::cloud::visionai::v1::Collection>
WarehouseClient::UpdateCollection(
    google::cloud::visionai::v1::UpdateCollectionRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->UpdateCollection(request);
}

StreamRange<google::cloud::visionai::v1::Collection>
WarehouseClient::ListCollections(std::string const& parent, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ListCollectionsRequest request;
  request.set_parent(parent);
  return connection_->ListCollections(request);
}

StreamRange<google::cloud::visionai::v1::Collection>
WarehouseClient::ListCollections(
    google::cloud::visionai::v1::ListCollectionsRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListCollections(std::move(request));
}

StatusOr<google::cloud::visionai::v1::AddCollectionItemResponse>
WarehouseClient::AddCollectionItem(
    google::cloud::visionai::v1::CollectionItem const& item, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::AddCollectionItemRequest request;
  *request.mutable_item() = item;
  return connection_->AddCollectionItem(request);
}

StatusOr<google::cloud::visionai::v1::AddCollectionItemResponse>
WarehouseClient::AddCollectionItem(
    google::cloud::visionai::v1::AddCollectionItemRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->AddCollectionItem(request);
}

StatusOr<google::cloud::visionai::v1::RemoveCollectionItemResponse>
WarehouseClient::RemoveCollectionItem(
    google::cloud::visionai::v1::CollectionItem const& item, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::RemoveCollectionItemRequest request;
  *request.mutable_item() = item;
  return connection_->RemoveCollectionItem(request);
}

StatusOr<google::cloud::visionai::v1::RemoveCollectionItemResponse>
WarehouseClient::RemoveCollectionItem(
    google::cloud::visionai::v1::RemoveCollectionItemRequest const& request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->RemoveCollectionItem(request);
}

StreamRange<google::cloud::visionai::v1::CollectionItem>
WarehouseClient::ViewCollectionItems(std::string const& collection,
                                     Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::cloud::visionai::v1::ViewCollectionItemsRequest request;
  request.set_collection(collection);
  return connection_->ViewCollectionItems(request);
}

StreamRange<google::cloud::visionai::v1::CollectionItem>
WarehouseClient::ViewCollectionItems(
    google::cloud::visionai::v1::ViewCollectionItemsRequest request,
    Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ViewCollectionItems(std::move(request));
}

StreamRange<google::cloud::location::Location> WarehouseClient::ListLocations(
    google::cloud::location::ListLocationsRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListLocations(std::move(request));
}

StatusOr<google::cloud::location::Location> WarehouseClient::GetLocation(
    google::cloud::location::GetLocationRequest const& request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetLocation(request);
}

StreamRange<google::longrunning::Operation> WarehouseClient::ListOperations(
    std::string const& name, std::string const& filter, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::longrunning::ListOperationsRequest request;
  request.set_name(name);
  request.set_filter(filter);
  return connection_->ListOperations(request);
}

StreamRange<google::longrunning::Operation> WarehouseClient::ListOperations(
    google::longrunning::ListOperationsRequest request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->ListOperations(std::move(request));
}

StatusOr<google::longrunning::Operation> WarehouseClient::GetOperation(
    std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::longrunning::GetOperationRequest request;
  request.set_name(name);
  return connection_->GetOperation(request);
}

StatusOr<google::longrunning::Operation> WarehouseClient::GetOperation(
    google::longrunning::GetOperationRequest const& request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->GetOperation(request);
}

Status WarehouseClient::DeleteOperation(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::longrunning::DeleteOperationRequest request;
  request.set_name(name);
  return connection_->DeleteOperation(request);
}

Status WarehouseClient::DeleteOperation(
    google::longrunning::DeleteOperationRequest const& request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->DeleteOperation(request);
}

Status WarehouseClient::CancelOperation(std::string const& name, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  google::longrunning::CancelOperationRequest request;
  request.set_name(name);
  return connection_->CancelOperation(request);
}

Status WarehouseClient::CancelOperation(
    google::longrunning::CancelOperationRequest const& request, Options opts) {
  internal::OptionsSpan span(internal::MergeOptions(std::move(opts), options_));
  return connection_->CancelOperation(request);
}

GOOGLE_CLOUD_CPP_INLINE_NAMESPACE_END
}  // namespace visionai_v1
}  // namespace cloud
}  // namespace google
